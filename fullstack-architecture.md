fullstack-architecture
双鼠探险家 全栈架构文档
简介
本文档为“双鼠探险家”游戏项目提供了完整的架构蓝图。它基于已有的产品需求文档（PRD）和 UI/UX 规范，旨在将游戏概念转化为一个具体、可实现的纯前端应用。
关键架构原则
- 简洁至上: 由于项目规模较小且技术栈简单，我们采用单文件组件化架构，将所有代码封装在一个 HTML 文件中。
- 模块化: 尽管是单文件，游戏代码仍将划分为逻辑清晰的模块（如游戏状态、渲染、输入处理、AI），以确保可维护性。
- 高性能: 游戏循环和动画将使用 requestAnimationFrame 进行优化，以实现流畅的性能。
技术栈



类别

编程语言

标记语言

样式表


技术

JavaScript

HTML

CSS


版本

ES6+

5

3


目的

核心游戏逻辑、交互和数据处理

游戏画布和基础页面结构

游戏画面的视觉表现和基本样式
高层架构
游戏将采用单体架构，所有功能都集中在一个 HTML 文件中。它遵循模型-视图-控制器 (MVC) 的简化模式，但所有逻辑都在一个文件中实现。
架构图
graph TD
    A[玩家输入] --> B(输入处理器);
    B --> C{游戏循环};
    C --> D[游戏状态管理器];
    D --> E[地图状态];
    D --> F[角色状态];
    D --> G[敌人状态];
    D --> H[奶酪状态];
    C --> I[渲染器];
    I --> J[画布];
    K[游戏逻辑] --> D;
    K --> C;

核心模块设计
1. 游戏状态管理器 (GameState)
该模块负责管理游戏的所有动态数据。
- 数据:
- playerState: 包含两个小鼠的位置、生命值、移动方向和共享血量。
- mapState: 包含两个地图的网格数据、障碍物位置和门的状态。
- enemyState: 包含所有小怪的位置、生命值和行为模式。
- cheeseState: 包含所有奶酪的位置。
- gameVariables: 包含积分、当前关卡、游戏状态（进行中/暂停/失败/通关）。
- 功能:
- update(): 根据玩家输入和游戏逻辑更新所有状态。
- isColliding(): 检测小鼠和奶酪或小怪之间的碰撞。
- checkWinCondition(): 检查玩家是否满足过关条件。
2. 渲染器 (Renderer)
该模块负责将游戏状态可视化到画布上。
- 功能:
- clearCanvas(): 清除画布内容。
- drawMap(): 绘制两个地图网格、障碍物和门。
- drawPlayer(): 绘制两个小鼠。
- drawEnemies(): 绘制所有小怪。
- drawCheese(): 绘制所有奶酪。
- drawUI(): 绘制积分和血量等 UI 元素。
3. 输入处理器 (InputHandler)
该模块负责监听键盘输入并将其转换为游戏动作。
- 功能:
- listen(): 监听方向键输入。
- onKeyPress(): 根据按下的键，更新 playerState 中的移动方向。
4. 游戏逻辑 (GameLogic)
该模块包含游戏的核心规则。
- 功能:
- movePlayer(): 根据输入更新玩家位置，并处理地图边界的循环穿越。
- moveEnemies(): 实现小怪的 AI 追踪逻辑。
- handleCollision(): 处理小鼠与小怪或奶酪的碰撞，更新生命值或积分。
- updateScore(): 更新积分并检查是否达到过关条件。
- checkGameState(): 根据血量或积分，切换游戏状态（通关、失败）。
5. 地图生成器 (MapGenerator)
该模块负责生成随机的地图。
- 功能:
- generate(): 生成一个正方形的网格，并随机放置障碍物和奶酪。
- getNewMap(): 在玩家通过门后，生成一个新的地图状态。
统一项目结构
项目将保持精简，所有文件都放在根目录下。
/
├── index.html     # 游戏主文件
├── style.css      # 游戏样式文件
└── main.js        # 核心游戏逻辑
下一步
架构设计已完成。接下来，我们将正式进入开发阶段。在开始编写代码之前，我们需要将所有史诗（Epics）和用户故事（User Stories）转化为可供开发者执行的任务。
现在，我将把项目移交给 Scrum Master，他将负责将你的 PRD 分解为具体的开发任务，并为每个任务创建清晰的故事文档。
你准备好让 Scrum Master 开始工作了吗？

