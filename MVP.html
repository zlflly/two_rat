<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>双鼠探险家</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #2c0e35;
            color: #d8bfd8;
            font-family: 'Inter', sans-serif;
            overflow: hidden;
        }
        h1 {
            color: #d8bfd8;
            text-shadow: 2px 2px 4px #000;
            text-align: center;
        }
        #game-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
        }
        .game-canvas {
            border: 2px solid #5d356b;
            background-color: #1a0820;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
        }
        #ui-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            text-align: center;
        }
        .status-bar {
            background-color: #5d356b;
            color: #fff;
            padding: 8px 15px;
            border-radius: 8px;
            min-width: 150px;
            text-align: center;
            font-size: 1.2em;
        }
        #message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(44, 14, 53, 0.9);
            border: 2px solid #d8bfd8;
            color: #d8bfd8;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            z-index: 100;
            display: none;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
        }
        #message-box button {
            background-color: #875d9e;
            color: white;
            border: none;
            padding: 10px 20px;
            margin-top: 15px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        #message-box button:hover {
            background-color: #a47bbd;
        }
        #message-box .button-group {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 15px;
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            margin: auto;
            display: none;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <h1>双鼠探险家</h1>
    <div id="ui-container">
        <div class="status-bar">积分: <span id="score">0</span></div>
        <div class="status-bar">血量: <span id="health"></span></div>
    </div>
    <div id="game-container">
        <canvas id="canvas1" class="game-canvas"></canvas>
        <canvas id="canvas2" class="game-canvas"></canvas>
    </div>

    <div id="message-box">
        <h2 id="message-text"></h2>
        <div id="message-content"></div>
        <div class="button-group">
            <button id="gemini-tip-button" style="display: none;">获取游戏小贴士 ✨</button>
            <button id="message-button">重新开始</button>
        </div>
        <div id="spinner" class="spinner"></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas1 = document.getElementById('canvas1');
            const ctx1 = canvas1.getContext('2d');
            const canvas2 = document.getElementById('canvas2');
            const ctx2 = canvas2.getContext('2d');
            const scoreElement = document.getElementById('score');
            const healthElement = document.getElementById('health');
            const messageBox = document.getElementById('message-box');
            const messageText = document.getElementById('message-text');
            const messageContent = document.getElementById('message-content');
            const messageButton = document.getElementById('message-button');
            const geminiTipButton = document.getElementById('gemini-tip-button');
            const spinner = document.getElementById('spinner');

            const gridSize = 30;
            const mapSize = 15;
            canvas1.width = canvas2.width = mapSize * gridSize;
            canvas1.height = canvas2.height = mapSize * gridSize;

            let gameState = {
                score: 0,
                health: 5,
                player1: { x: 7, y: 7 },
                player2: { x: 7, y: 7 },
                map1: [],
                map2: [],
                enemies1: [],
                enemies2: [],
                cheeses1: [],
                cheeses2: [],
                moving: false,
                gameOver: false,
                gameWon: false,
                pendingMove: null,
                gateCooldown: 0,
                gateCooldownDuration: 1000,
                hasReceivedTip: false // Gemini tip state
            };

            const mapColors = {
                background: '#1a0820',
                wall: '#5d356b',
                player: '#d8bfd8',
                cheese: '#f5b542',
                enemy: '#ff6666'
            };

            function generateMap() {
                const map = [];
                for (let y = 0; y < mapSize; y++) {
                    map[y] = [];
                    for (let x = 0; x < mapSize; x++) {
                        map[y][x] = Math.random() < 0.15 ? 1 : 0;
                    }
                }
                return map;
            }

            function generateCheeses() {
                const cheeses = [];
                const cheeseCount = 5;
                for (let i = 0; i < cheeseCount; i++) {
                    let pos;
                    do {
                        pos = {
                            x: Math.floor(Math.random() * mapSize),
                            y: Math.floor(Math.random() * mapSize)
                        };
                    } while (cheeses.some(c => c.x === pos.x && c.y === pos.y));
                    cheeses.push(pos);
                }
                return cheeses;
            }

            function generateEnemies() {
                const enemies = [];
                const enemyCount = 3;
                for (let i = 0; i < enemyCount; i++) {
                    let pos;
                    do {
                        pos = {
                            x: Math.floor(Math.random() * mapSize),
                            y: Math.floor(Math.random() * mapSize),
                            health: 1
                        };
                    } while (enemies.some(e => e.x === pos.x && e.y === pos.y));
                    enemies.push(pos);
                }
                return enemies;
            }

            function draw(ctx, map, player, cheeses, enemies) {
                ctx.fillStyle = mapColors.background;
                ctx.fillRect(0, 0, canvas1.width, canvas1.height);

                for (let y = 0; y < mapSize; y++) {
                    for (let x = 0; x < mapSize; x++) {
                        if (map[y][x] === 1) {
                            ctx.fillStyle = mapColors.wall;
                            ctx.fillRect(x * gridSize, y * gridSize, gridSize, gridSize);
                        }
                    }
                }

                cheeses.forEach(cheese => {
                    ctx.fillStyle = mapColors.cheese;
                    ctx.beginPath();
                    ctx.arc(cheese.x * gridSize + gridSize / 2, cheese.y * gridSize + gridSize / 2, gridSize / 4, 0, Math.PI * 2);
                    ctx.fill();
                });

                enemies.forEach(enemy => {
                    ctx.fillStyle = mapColors.enemy;
                    ctx.fillRect(enemy.x * gridSize + gridSize / 4, enemy.y * gridSize + gridSize / 4, gridSize / 2, gridSize / 2);
                });

                ctx.fillStyle = mapColors.player;
                ctx.fillRect(player.x * gridSize + gridSize / 4, player.y * gridSize + gridSize / 4, gridSize / 2, gridSize / 2);
            }

            function showMessage(text, content, buttonText, callback, showTipButton = false) {
                messageText.textContent = text;
                messageContent.textContent = content;
                messageButton.textContent = buttonText;
                messageBox.style.display = 'block';
                messageButton.onclick = callback;
                geminiTipButton.style.display = showTipButton ? 'inline-block' : 'none';
            }

            function updateUI() {
                scoreElement.textContent = gameState.score;
                let healthHearts = '';
                for (let i = 0; i < gameState.health; i++) {
                    healthHearts += '❤️';
                }
                healthElement.textContent = healthHearts;
            }

            function resetGame() {
                gameState.score = 0;
                gameState.health = 5;
                gameState.player1 = { x: 7, y: 7 };
                gameState.player2 = { x: 7, y: 7 };
                gameState.moving = false;
                gameState.gameOver = false;
                gameState.gameWon = false;
                gameState.pendingMove = null;
                gameState.gateCooldown = 0;
                gameState.hasReceivedTip = false;
                messageContent.textContent = '';
                startGame();
            }

            function startGame() {
                gameState.map1 = generateMap();
                gameState.map2 = generateMap();
                gameState.enemies1 = generateEnemies();
                gameState.enemies2 = generateEnemies();
                gameState.cheeses1 = generateCheeses();
                gameState.cheeses2 = generateCheeses();
                updateUI();
                gameLoop();
            }

            function refreshMaps() {
                gameState.map1 = generateMap();
                gameState.map2 = generateMap();
                gameState.enemies1 = generateEnemies();
                gameState.enemies2 = generateEnemies();
                gameState.cheeses1 = generateCheeses();
                gameState.cheeses2 = generateCheeses();
                updateUI();
            }

            function movePlayer(dx, dy) {
                if (gameState.moving || gameState.gameOver || gameState.gameWon) return;

                gameState.moving = true;
                gameState.pendingMove = { dx, dy };

                // Player 1
                const newX1 = gameState.player1.x + dx;
                const newY1 = gameState.player1.y + dy;
                let moved1 = false;
                
                if (newX1 >= 0 && newX1 < mapSize && newY1 >= 0 && newY1 < mapSize && gameState.map1[newY1][newX1] !== 1) {
                    gameState.player1.x = newX1;
                    gameState.player1.y = newY1;
                    moved1 = true;
                } else if (gameState.gateCooldown <= 0) {
                    if (newX1 < 0) { gameState.player1.x = mapSize - 1; refreshMaps(); moved1 = true; }
                    else if (newX1 >= mapSize) { gameState.player1.x = 0; refreshMaps(); moved1 = true; }
                    else if (newY1 < 0) { gameState.player1.y = mapSize - 1; refreshMaps(); moved1 = true; }
                    else if (newY1 >= mapSize) { gameState.player1.y = 0; refreshMaps(); moved1 = true; }
                }

                // Player 2
                const newX2 = gameState.player2.x + dx;
                const newY2 = gameState.player2.y + dy;
                let moved2 = false;

                if (newX2 >= 0 && newX2 < mapSize && newY2 >= 0 && newY2 < mapSize && gameState.map2[newY2][newX2] !== 1) {
                    gameState.player2.x = newX2;
                    gameState.player2.y = newY2;
                    moved2 = true;
                } else if (gameState.gateCooldown <= 0) {
                     if (newX2 < 0) { gameState.player2.x = mapSize - 1; refreshMaps(); moved2 = true; }
                    else if (newX2 >= mapSize) { gameState.player2.x = 0; refreshMaps(); moved2 = true; }
                    else if (newY2 < 0) { gameState.player2.y = mapSize - 1; refreshMaps(); moved2 = true; }
                    else if (newY2 >= mapSize) { gameState.player2.y = 0; refreshMaps(); moved2 = true; }
                }
                
                if (moved1 || moved2) {
                    gameState.gateCooldown = gameState.gateCooldownDuration;
                    handleGameLogic();
                    setTimeout(() => { gameState.moving = false; }, 100);
                } else {
                    gameState.moving = false;
                }
            }

            function moveEnemies() {
                // Enemies on Map 1
                gameState.enemies1.forEach(enemy => {
                    const dx = Math.sign(gameState.player1.x - enemy.x);
                    const dy = Math.sign(gameState.player1.y - enemy.y);
                    const newX = enemy.x + dx;
                    const newY = enemy.y + dy;

                    if (newX >= 0 && newX < mapSize && newY >= 0 && newY < mapSize && gameState.map1[newY][newX] !== 1) {
                        enemy.x = newX;
                        enemy.y = newY;
                    }
                });

                // Enemies on Map 2
                gameState.enemies2.forEach(enemy => {
                    const dx = Math.sign(gameState.player2.x - enemy.x);
                    const dy = Math.sign(gameState.player2.y - enemy.y);
                    const newX = enemy.x + dx;
                    const newY = enemy.y + dy;

                    if (newX >= 0 && newX < mapSize && newY >= 0 && newY < mapSize && gameState.map2[newY][newX] !== 1) {
                        enemy.x = newX;
                        enemy.y = newY;
                    }
                });
            }

            function handleCollisionsAndUpdates() {
                // Handle player-cheese collision
                gameState.cheeses1 = gameState.cheeses1.filter(cheese => {
                    if (cheese.x === gameState.player1.x && cheese.y === gameState.player1.y) {
                        gameState.score += 10;
                        return false;
                    }
                    return true;
                });
                gameState.cheeses2 = gameState.cheeses2.filter(cheese => {
                    if (cheese.x === gameState.player2.x && cheese.y === gameState.player2.y) {
                        gameState.score += 10;
                        return false;
                    }
                    return true;
                });
                
                // Handle player-enemy collision (player attacks)
                gameState.enemies1 = gameState.enemies1.filter(enemy => {
                    if (enemy.x === gameState.player1.x && enemy.y === gameState.player1.y) {
                        return false;
                    }
                    return true;
                });
                gameState.enemies2 = gameState.enemies2.filter(enemy => {
                    if (enemy.x === gameState.player2.x && enemy.y === gameState.player2.y) {
                        return false;
                    }
                    return true;
                });
                
                // Handle enemy-player collision (enemy attacks)
                gameState.enemies1.forEach(enemy => {
                    if (Math.abs(enemy.x - gameState.player1.x) + Math.abs(enemy.y - gameState.player1.y) <= 1 && gameState.pendingMove) {
                        gameState.health--;
                    }
                });
                gameState.enemies2.forEach(enemy => {
                    if (Math.abs(enemy.x - gameState.player2.x) + Math.abs(enemy.y - gameState.player2.y) <= 1 && gameState.pendingMove) {
                        gameState.health--;
                    }
                });
            }
            
            async function getGeminiTip() {
                spinner.style.display = 'block';
                geminiTipButton.disabled = true;
                messageContent.textContent = '';
                const userQuery = `我在一个双鼠探险家游戏里失败了。我的分数是 ${gameState.score}，初始血量是 5，现在血量是 ${gameState.health}。你能根据我的表现给我一个简短的游戏建议吗？这个游戏需要我同时控制两只小鼠，收集奶酪，同时躲避追踪我的小怪。我主动碰到小怪可以消灭它们，但被它们碰到就会掉血。`;
                const apiKey = "";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

                const payload = {
                    contents: [{ parts: [{ text: userQuery }] }],
                    tools: [{ "google_search": {} }],
                    systemInstruction: {
                        parts: [{ text: "你是一位富有经验的游戏教练，专为玩家提供简洁、富有鼓励性的游戏建议。你的回答应该简短、友好，并专注于提升玩家的游戏表现。" }]
                    }
                };

                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const result = await response.json();
                    const candidate = result.candidates?.[0];

                    if (candidate && candidate.content?.parts?.[0]?.text) {
                        messageContent.textContent = candidate.content.parts[0].text;
                    } else {
                        messageContent.textContent = "抱歉，暂时无法获取游戏小贴士。";
                    }
                } catch (error) {
                    console.error('Error fetching Gemini tip:', error);
                    messageContent.textContent = "获取小贴士时出错。";
                } finally {
                    spinner.style.display = 'none';
                    geminiTipButton.disabled = false;
                }
            }
            
            geminiTipButton.onclick = getGeminiTip;

            function handleGameLogic() {
                if (gameState.gameOver || gameState.gameWon) return;

                moveEnemies();
                handleCollisionsAndUpdates();

                if (gameState.health <= 0) {
                    gameState.gameOver = true;
                    if (!gameState.hasReceivedTip) {
                        showMessage('游戏失败', '血量耗尽了！', '重新开始', resetGame, true);
                        gameState.hasReceivedTip = true;
                    } else {
                        showMessage('游戏失败', '血量耗尽了！', '重新开始', resetGame);
                    }
                } else if (gameState.score >= 50) {
                    if (!gameState.gameWon) {
                        gameState.gameWon = true;
                        showMessage('通关！', '继续游戏以获得隐藏成就', '继续', () => { messageBox.style.display = 'none'; });
                    }
                }
            }

            function gameLoop() {
                if (gameState.gateCooldown > 0) {
                    gameState.gateCooldown -= 1000 / 60;
                }
                
                draw(ctx1, gameState.map1, gameState.player1, gameState.cheeses1, gameState.enemies1);
                draw(ctx2, gameState.map2, gameState.player2, gameState.cheeses2, gameState.enemies2);
                updateUI();
                requestAnimationFrame(gameLoop);
            }

            document.addEventListener('keydown', (e) => {
                if (gameState.moving) return;
                switch (e.key) {
                    case 'ArrowUp':
                        movePlayer(0, -1);
                        break;
                    case 'ArrowDown':
                        movePlayer(0, 1);
                        break;
                    case 'ArrowLeft':
                        movePlayer(-1, 0);
                        break;
                    case 'ArrowRight':
                        movePlayer(1, 0);
                        break;
                }
            });
            
            startGame();
        });
    </script>
</body>
</html>
